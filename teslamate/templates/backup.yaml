{{- if .Values.backup.enabled }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "teslamate.fullname" . }}-backup-script
  labels:
    {{- include "teslamate.labels" . | nindent 4 }}
    app.kubernetes.io/component: backup
data:
  backup.sh: |
    #!/bin/bash

    # Log file for capturing errors
    LOG_FILE="/tmp/backup_log.txt"
    exec > >(tee -a "${LOG_FILE}") 2>&1

    TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    BACKUP_FILE="teslamate_backup_${TIMESTAMP}.sql.gz"
    START_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # Function to send Discord notification
    send_discord_notification() {
      local success=$1
      local message=$2
      local error_log=$3

      if [ "${WEBHOOK_ENABLED}" != "true" ] || [ -z "${DISCORD_WEBHOOK_URL}" ]; then
        return 0
      fi

      python3 /scripts/discord_notify.py "${success}" "${message}" "${error_log}" "${BACKUP_FILE}" "${START_TIME}"
    }

    echo "Starting PostgreSQL backup at $(date)"

    # Install PostgreSQL client and required system packages
    echo "Installing PostgreSQL client..."
    if ! apt-get update -qq; then
      send_discord_notification "false" "Failed to update package lists" "${LOG_FILE}"
      exit 1
    fi

    if ! apt-get install -y -qq postgresql-client gzip curl; then
      send_discord_notification "false" "Failed to install required packages" "${LOG_FILE}"
      exit 1
    fi

    # Configuration
    GDRIVE_FOLDER_ID="${GDRIVE_FOLDER_ID}"

    # PostgreSQL connection info from environment variables
    export PGHOST="{{ include "teslamate.fullname" . }}-postgres"
    export PGPORT="5432"
    export PGUSER="${POSTGRES_USER}"
    export PGPASSWORD="${POSTGRES_PASSWORD}"
    export PGDATABASE="${POSTGRES_DB}"

    echo "Creating database dump..."
    if ! pg_dump -Fc -v -f "/tmp/${BACKUP_FILE%.gz}"; then
      send_discord_notification "false" "PostgreSQL dump failed" "${LOG_FILE}"
      exit 1
    fi

    echo "Compressing backup..."
    if ! gzip "/tmp/${BACKUP_FILE%.gz}"; then
      send_discord_notification "false" "Backup compression failed" "${LOG_FILE}"
      exit 1
    fi

    # Get backup file size
    BACKUP_SIZE=$(du -h "/tmp/${BACKUP_FILE}" | cut -f1)
    echo "Backup file size: ${BACKUP_SIZE}"

    echo "Installing Python dependencies..."
    if ! pip3 install --quiet --no-cache-dir google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client requests; then
      send_discord_notification "false" "Failed to install Python dependencies" "${LOG_FILE}"
      exit 1
    fi

    echo "Uploading to Google Drive..."
    if ! python3 /scripts/gdrive_upload.py "/tmp/${BACKUP_FILE}" "${GDRIVE_FOLDER_ID}"; then
      send_discord_notification "false" "Google Drive upload failed" "${LOG_FILE}"
      exit 1
    fi

    echo "Cleaning up local backup file..."
    rm -f "/tmp/${BACKUP_FILE}"

    echo "Backup completed successfully at $(date)"

    # Send success notification
    send_discord_notification "true" "Backup completed successfully. File size: ${BACKUP_SIZE}" ""

  gdrive_upload.py: |
    #!/usr/bin/env python3
    import os
    import sys
    from google.oauth2 import service_account
    from googleapiclient.discovery import build
    from googleapiclient.http import MediaFileUpload

    def upload_to_drive(file_path, folder_id):
        """Upload file to Google Drive."""

        # Load credentials from the mounted secret
        SCOPES = ['https://www.googleapis.com/auth/drive.file']
        credentials = service_account.Credentials.from_service_account_file(
            '/secrets/gdrive/credentials.json',
            scopes=SCOPES
        )

        # Build the Drive API service
        service = build('drive', 'v3', credentials=credentials)

        # Upload the backup file
        file_name = os.path.basename(file_path)
        file_metadata = {
            'name': file_name,
            'parents': [folder_id]
        }

        media = MediaFileUpload(file_path, resumable=True)

        print(f"Uploading {file_name} to Google Drive folder {folder_id}...")
        file = service.files().create(
            body=file_metadata,
            media_body=media,
            fields='id,name,createdTime'
        ).execute()

        print(f"Upload successful! File ID: {file.get('id')}")

    if __name__ == '__main__':
        if len(sys.argv) != 3:
            print("Usage: gdrive_upload.py <file_path> <folder_id>")
            sys.exit(1)

        file_path = sys.argv[1]
        folder_id = sys.argv[2]

        if not os.path.exists(file_path):
            print(f"Error: File not found: {file_path}")
            sys.exit(1)

        try:
            upload_to_drive(file_path, folder_id)
        except Exception as e:
            print(f"Error during upload: {str(e)}")
            import traceback
            traceback.print_exc()
            sys.exit(1)

  discord_notify.py: |
    #!/usr/bin/env python3
    import os
    import sys
    import json
    import requests
    from datetime import datetime

    def send_discord_notification(success, message, error_log_file, backup_file, start_time):
        """Send notification to Discord webhook."""

        webhook_url = os.environ.get('DISCORD_WEBHOOK_URL', '')
        if not webhook_url:
            print("Discord webhook URL not configured")
            return

        # Prepare embed color and title
        if success == "true":
            color = 0x00ff00  # Green
            title = "✅ TeslaMate Backup Successful"
        else:
            color = 0xff0000  # Red
            title = "❌ TeslaMate Backup Failed"

        # Build embed fields
        fields = [
            {
                "name": "Backup File",
                "value": f"`{backup_file}`",
                "inline": False
            },
            {
                "name": "Timestamp",
                "value": f"<t:{int(datetime.fromisoformat(start_time.replace('Z', '+00:00')).timestamp())}:F>",
                "inline": False
            }
        ]

        # Add message field
        if message:
            fields.append({
                "name": "Details",
                "value": message,
                "inline": False
            })

        # If failed, include error logs
        description = ""
        if success != "true" and error_log_file and os.path.exists(error_log_file):
            try:
                with open(error_log_file, 'r') as f:
                    log_content = f.read()
                    # Get last 50 lines or 1800 characters (Discord field limit is 1024, embed description is 4096)
                    log_lines = log_content.strip().split('\n')
                    error_snippet = '\n'.join(log_lines[-50:])
                    if len(error_snippet) > 1800:
                        error_snippet = error_snippet[-1800:]

                    description = f"```\n{error_snippet}\n```"
            except Exception as e:
                print(f"Failed to read error log: {e}")

        # Prepare Discord embed
        embed = {
            "title": title,
            "color": color,
            "fields": fields,
            "timestamp": start_time,
            "footer": {
                "text": "TeslaMate Database Backup"
            }
        }

        if description:
            embed["description"] = description

        payload = {
            "username": "TeslaMate Backup",
            "embeds": [embed]
        }

        # Send to Discord
        try:
            response = requests.post(
                webhook_url,
                json=payload,
                headers={"Content-Type": "application/json"},
                timeout=10
            )
            response.raise_for_status()
            print(f"Discord notification sent successfully (status: {response.status_code})")
        except requests.exceptions.RequestException as e:
            print(f"Failed to send Discord notification: {e}")
            if hasattr(e.response, 'text'):
                print(f"Response: {e.response.text}")

    if __name__ == '__main__':
        if len(sys.argv) != 6:
            print("Usage: discord_notify.py <success> <message> <error_log_file> <backup_file> <start_time>")
            sys.exit(1)

        success = sys.argv[1]
        message = sys.argv[2]
        error_log_file = sys.argv[3]
        backup_file = sys.argv[4]
        start_time = sys.argv[5]

        send_discord_notification(success, message, error_log_file, backup_file, start_time)
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: {{ include "teslamate.fullname" . }}-backup
  labels:
    {{- include "teslamate.labels" . | nindent 4 }}
    app.kubernetes.io/component: backup
spec:
  schedule: {{ .Values.backup.schedule | quote }}
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  concurrencyPolicy: Forbid
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            {{- include "teslamate.labels" . | nindent 12 }}
            app.kubernetes.io/component: backup
        spec:
          {{- with .Values.imagePullSecrets }}
          imagePullSecrets:
            {{- toYaml . | nindent 12 }}
          {{- end }}
          restartPolicy: OnFailure
          containers:
          - name: backup
            image: "{{ .Values.backup.image.repository }}:{{ .Values.backup.image.tag }}"
            imagePullPolicy: {{ .Values.backup.image.pullPolicy }}
            command:
            - /bin/bash
            - /scripts/backup.sh
            env:
            - name: POSTGRES_USER
              valueFrom:
                secretKeyRef:
                  name: "{{ include "teslamate.fullname" . }}-teslamate"
                  key: database_user
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: "{{ include "teslamate.fullname" . }}-teslamate"
                  key: database_pass
            - name: POSTGRES_DB
              valueFrom:
                secretKeyRef:
                  name: "{{ include "teslamate.fullname" . }}-teslamate"
                  key: database_name
            - name: GDRIVE_FOLDER_ID
              value: {{ .Values.backup.googleDrive.folderId | quote }}
            - name: WEBHOOK_ENABLED
              value: {{ .Values.backup.webhook.enabled | quote }}
            - name: DISCORD_WEBHOOK_URL
              value: {{ .Values.backup.webhook.discordUrl | quote }}
            volumeMounts:
            - name: backup-script
              mountPath: /scripts
            - name: gdrive-credentials
              mountPath: /secrets/gdrive
              readOnly: true
            {{- with .Values.backup.resources }}
            resources:
              {{- toYaml . | nindent 14 }}
            {{- end }}
          volumes:
          - name: backup-script
            configMap:
              name: {{ include "teslamate.fullname" . }}-backup-script
              defaultMode: 0755
          - name: gdrive-credentials
            secret:
              secretName: {{ .Values.backup.googleDrive.credentialsSecretName }}
          {{- with .Values.backup.nodeSelector }}
          nodeSelector:
            {{- toYaml . | nindent 12 }}
          {{- end }}
          {{- with .Values.backup.affinity }}
          affinity:
            {{- toYaml . | nindent 12 }}
          {{- end }}
          {{- with .Values.backup.tolerations }}
          tolerations:
            {{- toYaml . | nindent 12 }}
          {{- end }}
{{- end }}
